# Настройка

Ура, ты решил перейти на telegrinder. Возможно, потому что хочешь что-то новое и прикольное. Или, может быть, это твой первый опыт с ботами. Этот туториал подойдет для обоих случаев. Начнем с инициализации основной сущности - самого бота.

Для начала нужно создать токен через BotFather и импортировать несколько классов из модуля:

```python
from telegrinder import Telegrinder, API, Token

api = API(Token("your-token-here"))
bot = Telegrinder(api)
```

Здесь мы создаем три сущности:

Твой токен, который в telegrinder — это не просто строка, а экземпляр Token. Это нужно для строгой типизации и соображений безопасности. Еще у Token есть некоторые методы, которые могут понадобиться позже.

Далее API — это экземпляр для обращения к Telegram API. Позже в туториале мы разберем, как с ним работать.

И наконец, основная сущность — Telegrinder, который собирает все компоненты, чтобы запускать бота.

Теперь, когда мы создали основную сущность, нужно описать в ней логику. Боты пишутся на основе событий. Мы получаем событие от Telegram, например: "Георгий прислал сообщение с текстом 'privetik'" или "Арсений прислал стикер". В telegrinder мы декларируем хендлеры для каждого типа события, которое нам надо обработать. Для объявления хендлеров удобно использовать декораторы — так проще привязать функцию к событию.

Допустим, мы хотим обрабатывать любое сообщение и отправлять его обратно. Добавим хендлер в код:

```python
# Добавим импорт
from telegrinder import Message

@bot.on.message()
async def message_handler(message: Message):
    if message.text:
        await message.answer(message.text.unwrap())
```

В конце файла обязательно нужно добавить эту строку:

```python
bot.run_forever()
```

Она запустит бота в асинхронном режиме, и будет получать и обрабатывать обновления в цикле.

Разберем код. Мы создали новый хендлер, который реализует логику. Строка `@bot.on.message()` понятна — мы говорим, что этот хендлер будет вызываться при каждом получении сообщения.

Когда приходит сообщение, функция получает его как расширенный объект события (так называемый CuteType в telegrinder).

Если используешь приемлемую IDE вроде VS Code с Pylance, будут подсказки по содержимому всех типов данных, так как telegrinder полностью типизирован.

Мы использовали метод answer, который уже встроен в CuteType Message. Он вызывает метод `send_message` в Telegram с уже указанным `chat_id`.

Перед отправкой сообщения мы проверяем, что в нем есть текст, ведь сообщение может быть пустым - например просто фото или стикер. В telegrinder используются функциональные типы, чтобы мы всегда контролировали что у нас в объектах: поэтому мы вызываем `.unwrap()`. Мы детальнее разберем это позже.

Для примера, немного доработаем код — если текста нет, будем отправлять "Нет текста" вместо того, чтобы ничего не отвечать.

```python
@bot.on.message()
async def message_handler(message: Message):
    await message.answer(message.text.unwrap_or("Нет текста"))
```

Вот так это работает.

Если ты не забыл добавить `bot.run_forever()` в конце, то все должно работать: можно получать эхо-ответы на сообщения.

В следующей части туториала разберем правила — важную вещь, чтобы добавить разнообразие в хендлеры. Каждый хендлер будет выполнять свое, а для того чтобы распределнить события, необходима фильтрация.

[>> Next: Правила](2_rules.md)
